# ============================================================================
# COREDNS - CONFIGURACIÓN Y PERSONALIZACIÓN
# ============================================================================
# DNS service discovery para Services y Pods en Kubernetes
# ============================================================================

# ✅ EJECUTABLE EN MINIKUBE - CON NOTAS:
# ────────────────────────────────────────────────────────────────────────────
# CoreDNS ya viene instalado en Minikube por defecto.
# 
# Este archivo muestra cómo está configurado y cómo personalizarlo.
# 
# Para ver la configuración actual de CoreDNS en Minikube:
# $ kubectl get deployment -n kube-system coredns
# $ kubectl get configmap -n kube-system coredns -o yaml
# $ kubectl get svc -n kube-system kube-dns
# 
# Para MODIFICAR la configuración de CoreDNS:
# $ kubectl edit configmap -n kube-system coredns
# 
# Para ver logs de CoreDNS:
# $ kubectl logs -n kube-system -l k8s-app=kube-dns --tail=50
# 
# ⚠️ NOTA sobre este archivo:
# • Los ejemplos de ConfigMap personalizados SÍ son ejecutables
# • El Deployment mostrado es REFERENCIA (ya existe en el cluster)
# • Puedes crear ConfigMaps personalizados para testing
# ────────────────────────────────────────────────────────────────────────────

---
# ============================================================================
# DEPLOYMENT DE COREDNS (REFERENCIA)
# ============================================================================
# Este Deployment ya existe en Minikube. NO lo apliques directamente.
# Úsalo como referencia para entender la configuración.

apiVersion: apps/v1
kind: Deployment
metadata:
  name: coredns
  namespace: kube-system
  labels:
    k8s-app: kube-dns
    kubernetes.io/name: "CoreDNS"
spec:
  replicas: 2  # HA: mínimo 2 réplicas
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
  selector:
    matchLabels:
      k8s-app: kube-dns
  template:
    metadata:
      labels:
        k8s-app: kube-dns
    spec:
      priorityClassName: system-cluster-critical
      serviceAccountName: coredns
      tolerations:
      - key: "CriticalAddonsOnly"
        operator: "Exists"
      - key: node-role.kubernetes.io/control-plane
        operator: Exists
        effect: NoSchedule
      nodeSelector:
        kubernetes.io/os: linux
      
      # Anti-affinity para distribuir en diferentes nodos
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: k8s-app
                  operator: In
                  values:
                  - kube-dns
              topologyKey: kubernetes.io/hostname
      
      containers:
      - name: coredns
        image: registry.k8s.io/coredns/coredns:v1.10.1
        imagePullPolicy: IfNotPresent
        resources:
          limits:
            memory: 170Mi
          requests:
            cpu: 100m
            memory: 70Mi
        args: [ "-conf", "/etc/coredns/Corefile" ]
        volumeMounts:
        - name: config-volume
          mountPath: /etc/coredns
          readOnly: true
        ports:
        - containerPort: 53
          name: dns
          protocol: UDP
        - containerPort: 53
          name: dns-tcp
          protocol: TCP
        - containerPort: 9153
          name: metrics
          protocol: TCP
        
        # Health checks
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
            scheme: HTTP
          initialDelaySeconds: 60
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 5
        
        readinessProbe:
          httpGet:
            path: /ready
            port: 8181
            scheme: HTTP
        
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            add:
            - NET_BIND_SERVICE
            drop:
            - all
          readOnlyRootFilesystem: true
      
      dnsPolicy: Default
      volumes:
      - name: config-volume
        configMap:
          name: coredns
          items:
          - key: Corefile
            path: Corefile

---
# ============================================================================
# SERVICE PARA COREDNS
# ============================================================================

apiVersion: v1
kind: Service
metadata:
  name: kube-dns
  namespace: kube-system
  annotations:
    prometheus.io/port: "9153"
    prometheus.io/scrape: "true"
  labels:
    k8s-app: kube-dns
    kubernetes.io/cluster-service: "true"
    kubernetes.io/name: "CoreDNS"
spec:
  selector:
    k8s-app: kube-dns
  clusterIP: 10.96.0.10  # IP fija (referenciada en kubelet config)
  ports:
  - name: dns
    port: 53
    protocol: UDP
    targetPort: 53
  - name: dns-tcp
    port: 53
    protocol: TCP
    targetPort: 53
  - name: metrics
    port: 9153
    protocol: TCP
    targetPort: 9153

---
# ============================================================================
# CONFIGMAP CON COREFILE
# ============================================================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: coredns
  namespace: kube-system
data:
  Corefile: |
    .:53 {
        # ──────────────────────────────────────────────────────
        # ERRORS: Log errors to stdout
        # ──────────────────────────────────────────────────────
        errors
        
        # ──────────────────────────────────────────────────────
        # HEALTH: Endpoint /health en puerto 8080
        # ──────────────────────────────────────────────────────
        health {
           lameduck 5s
        }
        
        # ──────────────────────────────────────────────────────
        # READY: Endpoint /ready en puerto 8181
        # ──────────────────────────────────────────────────────
        ready
        
        # ──────────────────────────────────────────────────────
        # KUBERNETES: Plugin principal para resolución
        # ──────────────────────────────────────────────────────
        kubernetes cluster.local in-addr.arpa ip6.arpa {
           # Resolver pods (A records para pod IPs)
           pods insecure
           
           # Fallthrough para zonas reversas
           fallthrough in-addr.arpa ip6.arpa
           
           # TTL para registros DNS
           ttl 30
        }
        
        # ──────────────────────────────────────────────────────
        # PROMETHEUS: Métricas en puerto 9153
        # ──────────────────────────────────────────────────────
        prometheus :9153
        
        # ──────────────────────────────────────────────────────
        # FORWARD: Queries externas a upstream DNS
        # ──────────────────────────────────────────────────────
        forward . /etc/resolv.conf {
           max_concurrent 1000
        }
        
        # ──────────────────────────────────────────────────────
        # CACHE: Cache de respuestas DNS
        # ──────────────────────────────────────────────────────
        cache 30
        
        # ──────────────────────────────────────────────────────
        # LOOP: Detecta loops de resolución
        # ──────────────────────────────────────────────────────
        loop
        
        # ──────────────────────────────────────────────────────
        # RELOAD: Recarga Corefile automáticamente
        # ──────────────────────────────────────────────────────
        reload
        
        # ──────────────────────────────────────────────────────
        # LOADBALANCE: Round-robin entre A/AAAA records
        # ──────────────────────────────────────────────────────
        loadbalance
    }

---
# ============================================================================
# CONFIGURACIÓN AVANZADA: CUSTOM DNS ENTRIES
# ============================================================================

# Ejemplo: Agregar entradas DNS personalizadas
apiVersion: v1
kind: ConfigMap
metadata:
  name: coredns
  namespace: kube-system
data:
  Corefile: |
    .:53 {
        errors
        health {
           lameduck 5s
        }
        ready
        
        kubernetes cluster.local in-addr.arpa ip6.arpa {
           pods insecure
           fallthrough in-addr.arpa ip6.arpa
           ttl 30
        }
        
        prometheus :9153
        
        # ──────────────────────────────────────────────────────
        # HOSTS: Entradas estáticas personalizadas
        # ──────────────────────────────────────────────────────
        hosts {
           # IP interna para servicio externo
           192.168.100.50 database.example.com
           192.168.100.51 cache.example.com
           
           fallthrough
        }
        
        # ──────────────────────────────────────────────────────
        # REWRITE: Reescribir queries
        # ──────────────────────────────────────────────────────
        rewrite name suffix .local .cluster.local
        
        forward . /etc/resolv.conf {
           max_concurrent 1000
        }
        
        cache 30
        loop
        reload
        loadbalance
    }

---
# ============================================================================
# CONFIGURACIÓN: SPLIT DNS (múltiples zonas)
# ============================================================================

# Ejemplo: Diferentes upstream DNS por zona
apiVersion: v1
kind: ConfigMap
metadata:
  name: coredns
  namespace: kube-system
data:
  Corefile: |
    # ──────────────────────────────────────────────────────
    # ZONA: cluster.local (interno)
    # ──────────────────────────────────────────────────────
    cluster.local:53 {
        errors
        cache 30
        kubernetes cluster.local in-addr.arpa ip6.arpa {
           pods insecure
           fallthrough in-addr.arpa ip6.arpa
           ttl 30
        }
    }
    
    # ──────────────────────────────────────────────────────
    # ZONA: company.internal (DNS corporativo)
    # ──────────────────────────────────────────────────────
    company.internal:53 {
        errors
        cache 30
        forward . 10.100.0.10 10.100.0.11
    }
    
    # ──────────────────────────────────────────────────────
    # ZONA: . (todo lo demás - Internet)
    # ──────────────────────────────────────────────────────
    .:53 {
        errors
        health
        ready
        prometheus :9153
        forward . 8.8.8.8 8.8.4.4
        cache 30
        loop
        reload
        loadbalance
    }

---
# ============================================================================
# SERVICEACCOUNT Y RBAC
# ============================================================================

apiVersion: v1
kind: ServiceAccount
metadata:
  name: coredns
  namespace: kube-system

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: system:coredns
rules:
- apiGroups: [""]
  resources: ["endpoints", "services", "pods", "namespaces"]
  verbs: ["list", "watch"]
- apiGroups: ["discovery.k8s.io"]
  resources: ["endpointslices"]
  verbs: ["list", "watch"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: system:coredns
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:coredns
subjects:
- kind: ServiceAccount
  name: coredns
  namespace: kube-system

---
# ============================================================================
# PRUEBAS DE DNS
# ============================================================================

# ──────────────────────────────────────────────────────────────
# PRUEBA 1: Resolver un Service
# ──────────────────────────────────────────────────────────────

# $ kubectl run test-dns --rm -it --image=busybox -- sh
# 
# / # nslookup kubernetes
# Server:    10.96.0.10
# Address:   10.96.0.10:53
# 
# Name:      kubernetes.default.svc.cluster.local
# Address:   10.96.0.1

# ──────────────────────────────────────────────────────────────
# PRUEBA 2: Resolver Service en otro namespace
# ──────────────────────────────────────────────────────────────

# / # nslookup backend.production.svc.cluster.local
# Server:    10.96.0.10
# Address:   10.96.0.10:53
# 
# Name:      backend.production.svc.cluster.local
# Address:   10.96.100.50

# ──────────────────────────────────────────────────────────────
# PRUEBA 3: Resolver nombre externo
# ──────────────────────────────────────────────────────────────

# / # nslookup google.com
# Server:    10.96.0.10
# Address:   10.96.0.10:53
# 
# Non-authoritative answer:
# Name:      google.com
# Address:   142.250.185.46

# ──────────────────────────────────────────────────────────────
# PRUEBA 4: Verificar métricas de CoreDNS
# ──────────────────────────────────────────────────────────────

# $ kubectl port-forward -n kube-system svc/kube-dns 9153:9153
# $ curl http://localhost:9153/metrics
# 
# # Métricas clave:
# coredns_dns_request_count_total
# coredns_dns_request_duration_seconds
# coredns_cache_hits_total
# coredns_cache_misses_total

---
# ============================================================================
# TROUBLESHOOTING DNS
# ============================================================================

# ──────────────────────────────────────────────────────────────
# PROBLEMA: Pods no pueden resolver nombres
# ──────────────────────────────────────────────────────────────

# 1. Verificar que CoreDNS está corriendo
# $ kubectl get pods -n kube-system -l k8s-app=kube-dns
# NAME                      READY   STATUS    RESTARTS   AGE
# coredns-abc123-xyz       1/1     Running   0          10m
# coredns-def456-uvw       1/1     Running   0          10m

# 2. Verificar Service kube-dns
# $ kubectl get svc -n kube-system kube-dns
# NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
# kube-dns   ClusterIP   10.96.0.10   <none>        53/UDP,53/TCP   10m

# 3. Verificar /etc/resolv.conf en un pod
# $ kubectl run test --rm -it --image=busybox -- cat /etc/resolv.conf
# nameserver 10.96.0.10
# search default.svc.cluster.local svc.cluster.local cluster.local
# options ndots:5

# 4. Ver logs de CoreDNS
# $ kubectl logs -n kube-system -l k8s-app=kube-dns

# 5. Probar resolución directa
# $ kubectl run test --rm -it --image=busybox -- nslookup kubernetes 10.96.0.10

# ──────────────────────────────────────────────────────────────
# PROBLEMA: Alta latencia en resolución DNS
# ──────────────────────────────────────────────────────────────

# 1. Aumentar cache TTL en Corefile
# cache 300  # 5 minutos en lugar de 30 segundos

# 2. Escalar réplicas de CoreDNS
# $ kubectl scale deployment coredns -n kube-system --replicas=3

# 3. Ajustar recursos
# $ kubectl set resources deployment coredns -n kube-system \
#   --limits=memory=256Mi \
#   --requests=cpu=200m,memory=128Mi

---
# ============================================================================
# NOTAS IMPORTANTES
# ============================================================================
# 
# ✓ CoreDNS es el DNS por defecto desde Kubernetes 1.13+
# ✓ Cada pod automáticamente tiene nameserver apuntando a CoreDNS
# ✓ Formatos DNS: service, service.namespace, service.namespace.svc.cluster.local
# ✓ Pods pueden resolver Services en cualquier namespace
# ✓ CoreDNS usa Watch API para detectar cambios en Services
# ✓ Cache reduce carga en API Server
# ✓ Mínimo 2 réplicas de CoreDNS en producción
# ✓ Anti-affinity asegura distribución en diferentes nodos
# ✓ Métricas Prometheus disponibles en puerto 9153
# ✓ ndots:5 significa que nombres con <5 dots se buscan con search domains
# 
# FORMATO DNS PARA SERVICES:
# • <service-name>
# • <service-name>.<namespace>
# • <service-name>.<namespace>.svc
# • <service-name>.<namespace>.svc.cluster.local
# 
# FORMATO DNS PARA PODS (si pods insecure habilitado):
# • <pod-ip-with-dashes>.<namespace>.pod.cluster.local
# • Ejemplo: 10-244-1-5.default.pod.cluster.local
# 
# ============================================================================
