# ============================================================================
# Configuración de la aplicación
# ============================================================================
app:
  name: advanced-app
  replicaCount: 3
  
  image:
    repository: nginx
    tag: "1.23.0"
    pullPolicy: IfNotPresent
  
  service:
    type: ClusterIP
    port: 80
    targetPort: http
  
  # Ingress configuration
  ingress:
    enabled: true
    className: nginx
    annotations:
      cert-manager.io/cluster-issuer: letsencrypt-prod
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
    hosts:
      - host: app.example.com
        paths:
          - path: /
            pathType: Prefix
      - host: api.example.com
        paths:
          - path: /api
            pathType: Prefix
    tls:
      - secretName: app-tls
        hosts:
          - app.example.com
      - secretName: api-tls
        hosts:
          - api.example.com
  
  # Resource management
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "200m"
  
  # Health checks
  livenessProbe:
    httpGet:
      path: /healthz
      port: http
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3
  
  readinessProbe:
    httpGet:
      path: /ready
      port: http
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    successThreshold: 1
    failureThreshold: 3
  
  # Autoscaling
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
  
  # Security context
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 2000
    capabilities:
      drop:
        - ALL
      add:
        - NET_BIND_SERVICE
    readOnlyRootFilesystem: true
  
  # Environment variables
  env:
    - name: APP_ENV
      value: "production"
    - name: LOG_LEVEL
      value: "info"
    - name: PORT
      value: "8080"
  
  # Environment from ConfigMap/Secret
  envFrom:
    - configMapRef:
        name: app-config
    - secretRef:
        name: app-secrets

# ============================================================================
# ConfigMap data
# ============================================================================
configMap:
  enabled: true
  data:
    app.conf: |
      server {
        listen 80;
        server_name localhost;
        
        location / {
          root /usr/share/nginx/html;
          index index.html;
        }
        
        location /api {
          proxy_pass http://backend:3000;
        }
      }
    database.conf: |
      host: postgres.default.svc.cluster.local
      port: 5432
      database: appdb
      pool_size: 10

# ============================================================================
# Secret data (Base64 encoded)
# ============================================================================
secret:
  enabled: true
  # En producción, usar external secrets o sealed secrets
  data:
    db-password: cGFzc3dvcmQxMjM=  # password123
    api-key: YXBpa2V5LXNlY3JldC12YWx1ZQ==  # apikey-secret-value

# ============================================================================
# ServiceAccount
# ============================================================================
serviceAccount:
  create: true
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789:role/app-role
  name: ""  # Si vacío, usa el nombre del release

# ============================================================================
# PodDisruptionBudget
# ============================================================================
podDisruptionBudget:
  enabled: true
  minAvailable: 1
  # maxUnavailable: 1

# ============================================================================
# NetworkPolicy
# ============================================================================
networkPolicy:
  enabled: true
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
      - podSelector:
          matchLabels:
            role: frontend
      ports:
      - protocol: TCP
        port: 80
  egress:
    - to:
      - podSelector:
          matchLabels:
            role: database
      ports:
      - protocol: TCP
        port: 5432

# ============================================================================
# Labels y Annotations globales
# ============================================================================
commonLabels:
  app.kubernetes.io/managed-by: helm
  app.kubernetes.io/part-of: microservices
  environment: production
  team: platform

commonAnnotations:
  deployed-by: helm
  version: "2.0"

# ============================================================================
# Configuración de nodos
# ============================================================================
nodeSelector:
  kubernetes.io/os: linux
  node-type: application

tolerations:
  - key: "app"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app
                operator: In
                values:
                  - advanced-app
          topologyKey: kubernetes.io/hostname

# ============================================================================
# Persistence (PVC)
# ============================================================================
persistence:
  enabled: false
  storageClass: "standard"
  accessMode: ReadWriteOnce
  size: 1Gi
  mountPath: /data
