# ============================================
# EJEMPLOS DE SERVICES EN KUBERNETES
# ============================================
# Este archivo contiene ejemplos completos de todos los tipos de Services
# para networking en Kubernetes

---
# ============================================
# 1. CLUSTERIP SERVICE (Default - Interno)
# ============================================
# Expone el servicio solo dentro del cluster
# Es el tipo por defecto si no se especifica

apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: default
  labels:
    app: backend
    tier: backend
  annotations:
    description: "ClusterIP service for internal backend communication"
spec:
  type: ClusterIP
  selector:
    app: backend
    tier: backend
  ports:
    - name: http
      protocol: TCP
      port: 80          # Puerto del Service
      targetPort: 8080  # Puerto del Pod
    - name: metrics
      protocol: TCP
      port: 9090
      targetPort: 9090
  sessionAffinity: ClientIP  # Sticky sessions basadas en IP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 10800  # 3 horas

---
# ============================================
# 2. NODEPORT SERVICE (Externo - Básico)
# ============================================
# Expone el servicio en un puerto estático en cada nodo
# Rango: 30000-32767

apiVersion: v1
kind: Service
metadata:
  name: frontend-nodeport
  namespace: default
  labels:
    app: frontend
    tier: frontend
  annotations:
    description: "NodePort service for external frontend access"
spec:
  type: NodePort
  selector:
    app: frontend
    tier: frontend
  ports:
    - name: http
      protocol: TCP
      port: 80          # Puerto del Service (interno)
      targetPort: 3000  # Puerto del Pod
      nodePort: 30080   # Puerto expuesto en cada nodo (30000-32767)
  externalTrafficPolicy: Local  # Preserva IP origen, pero sin balanceo entre nodos
  
---
# ============================================
# 3. LOADBALANCER SERVICE (Cloud Provider)
# ============================================
# Provisiona un Load Balancer externo (AWS ELB, Azure LB, GCP LB)

apiVersion: v1
kind: Service
metadata:
  name: webapp-loadbalancer
  namespace: production
  labels:
    app: webapp
    environment: production
  annotations:
    description: "LoadBalancer service for production webapp"
    # Annotations específicas del cloud provider
    service.beta.kubernetes.io/azure-load-balancer-internal: "false"
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"  # Network Load Balancer
    service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
spec:
  type: LoadBalancer
  selector:
    app: webapp
    environment: production
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 8080
    - name: https
      protocol: TCP
      port: 443
      targetPort: 8443
  externalTrafficPolicy: Local  # Preserva IP origen
  loadBalancerSourceRanges:     # Restricción de IPs permitidas
    - 203.0.113.0/24
    - 198.51.100.0/24

---
# ============================================
# 4. HEADLESS SERVICE (Sin ClusterIP)
# ============================================
# Para acceso directo a pods, usado con StatefulSets

apiVersion: v1
kind: Service
metadata:
  name: database-headless
  namespace: default
  labels:
    app: database
    tier: database
  annotations:
    description: "Headless service for direct pod access in StatefulSet"
spec:
  clusterIP: None  # Headless service (sin ClusterIP)
  selector:
    app: database
    tier: database
  ports:
    - name: postgres
      protocol: TCP
      port: 5432
      targetPort: 5432
  publishNotReadyAddresses: true  # Incluye pods no-ready en DNS

---
# ============================================
# 5. EXTERNALNAME SERVICE (DNS CNAME)
# ============================================
# Mapea el servicio a un nombre DNS externo

apiVersion: v1
kind: Service
metadata:
  name: external-api
  namespace: default
  annotations:
    description: "ExternalName service mapping to external API"
spec:
  type: ExternalName
  externalName: api.external-service.com  # DNS externo
  ports:
    - name: https
      protocol: TCP
      port: 443

---
# ============================================
# 6. MULTI-PORT SERVICE
# ============================================
# Service con múltiples puertos y protocolos

apiVersion: v1
kind: Service
metadata:
  name: app-multi-port
  namespace: default
  labels:
    app: microservice
  annotations:
    description: "Multi-port service for microservice"
spec:
  type: ClusterIP
  selector:
    app: microservice
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 8080
    - name: grpc
      protocol: TCP
      port: 9000
      targetPort: 9000
    - name: metrics
      protocol: TCP
      port: 9090
      targetPort: 9090
    - name: health
      protocol: TCP
      port: 8081
      targetPort: 8081

---
# ============================================
# 7. SERVICE CON SESSION AFFINITY
# ============================================
# Sticky sessions para mantener conexiones del mismo cliente

apiVersion: v1
kind: Service
metadata:
  name: stateful-app-service
  namespace: default
  labels:
    app: stateful-app
  annotations:
    description: "Service with session affinity for stateful applications"
spec:
  type: ClusterIP
  selector:
    app: stateful-app
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 86400  # 24 horas
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 8080

---
# ============================================
# 8. SERVICE SIN SELECTOR (Endpoints Manuales)
# ============================================
# Service para endpoints externos o manuales

apiVersion: v1
kind: Service
metadata:
  name: external-database
  namespace: default
  annotations:
    description: "Service without selector for external database"
spec:
  type: ClusterIP
  ports:
    - name: mysql
      protocol: TCP
      port: 3306
      targetPort: 3306
  # No selector - se crean Endpoints manualmente

---
# Endpoints manuales para el service anterior
apiVersion: v1
kind: Endpoints
metadata:
  name: external-database  # Debe coincidir con el Service
  namespace: default
subsets:
  - addresses:
      - ip: 192.168.1.100  # IP del servidor externo
    ports:
      - name: mysql
        port: 3306
        protocol: TCP

---
# ============================================
# 9. SERVICE CON TOPOLOGY AWARE ROUTING
# ============================================
# Routing basado en topología (zone-aware)

apiVersion: v1
kind: Service
metadata:
  name: api-topology-aware
  namespace: default
  labels:
    app: api
  annotations:
    description: "Service with topology-aware routing"
spec:
  type: ClusterIP
  selector:
    app: api
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 8080
  topologyKeys:  # Preferencia de routing
    - "kubernetes.io/hostname"  # Mismo nodo primero
    - "topology.kubernetes.io/zone"  # Misma zona después
    - "*"  # Cualquier zona finalmente

---
# ============================================
# 10. SERVICE PARA STATEFULSET
# ============================================
# Headless service para StatefulSet con DNS estable

apiVersion: v1
kind: Service
metadata:
  name: mongodb-statefulset-service
  namespace: databases
  labels:
    app: mongodb
    component: database
  annotations:
    description: "Headless service for MongoDB StatefulSet"
spec:
  clusterIP: None  # Headless
  selector:
    app: mongodb
    component: database
  ports:
    - name: mongodb
      protocol: TCP
      port: 27017
      targetPort: 27017
  publishNotReadyAddresses: true

---
# ============================================
# COMANDOS ÚTILES PARA TESTING
# ============================================

# Crear todos los services:
# kubectl apply -f services-examples.yaml

# Listar services:
# kubectl get svc -A
# kubectl get svc -o wide

# Ver detalles de un service:
# kubectl describe svc backend-service

# Ver endpoints de un service:
# kubectl get endpoints backend-service

# Probar conectividad desde un pod:
# kubectl run test-pod --image=busybox --rm -it -- wget -O- http://backend-service

# Ver el ClusterIP asignado:
# kubectl get svc backend-service -o jsonpath='{.spec.clusterIP}'

# Ver el NodePort asignado:
# kubectl get svc frontend-nodeport -o jsonpath='{.spec.ports[0].nodePort}'

# Ver LoadBalancer IP:
# kubectl get svc webapp-loadbalancer -o jsonpath='{.status.loadBalancer.ingress[0].ip}'

# Probar NodePort desde fuera del cluster:
# curl http://<NODE-IP>:30080

# Ver registros DNS de headless service:
# kubectl run -it --rm debug --image=busybox --restart=Never -- nslookup database-headless

# Editar service:
# kubectl edit svc backend-service

# Eliminar service:
# kubectl delete svc backend-service

# Port-forward para testing local:
# kubectl port-forward svc/backend-service 8080:80

# Ver logs de kube-proxy (si hay problemas):
# kubectl logs -n kube-system -l k8s-app=kube-proxy

# Ver reglas iptables de services (en el nodo):
# sudo iptables-save | grep backend-service
