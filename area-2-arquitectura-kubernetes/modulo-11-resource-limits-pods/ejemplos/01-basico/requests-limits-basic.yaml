# =============================================================================
# Ejemplo 01: Requests y Limits Básicos
# =============================================================================
# 
# Este ejemplo demuestra la configuración básica de requests y limits para
# contenedores en un Pod.
#
# Conceptos cubiertos:
# - Requests: Recursos mínimos garantizados
# - Limits: Recursos máximos permitidos
# - CPU en millicores (m)
# - Memory en MiB/GiB
# - Múltiples contenedores en un Pod
#
# QoS Class resultante: Burstable
# (porque request < limit)
# =============================================================================

apiVersion: v1
kind: Pod
metadata:
  name: requests-limits-basic
  labels:
    app: demo
    example: basic-resources
  annotations:
    description: "Ejemplo básico de requests y limits"
spec:
  containers:
  - name: nginx
    image: nginx:1.25-alpine
    resources:
      # Requests: Lo que el Pod GARANTIZA que tendrá disponible
      # El scheduler usa estos valores para decidir en qué nodo colocar el Pod
      requests:
        cpu: "250m"      # 0.25 CPU cores (millicores)
        memory: "128Mi"  # 128 Mebibytes de RAM
      
      # Limits: Lo que el Pod MÁXIMO puede usar
      # El kubelet enforza estos límites:
      # - CPU: Throttling (restricción, no termina)
      # - Memory: OOMKilled (termina el proceso, Exit Code 137)
      limits:
        cpu: "500m"      # 0.5 CPU cores máximo
        memory: "256Mi"  # 256 MiB máximo
    
    ports:
    - containerPort: 80
    
    # Verificar que el contenedor arranca correctamente
    livenessProbe:
      httpGet:
        path: /
        port: 80
      initialDelaySeconds: 5
      periodSeconds: 10

---
# =============================================================================
# Ejemplo 02: Pod con Múltiples Contenedores
# =============================================================================
#
# Los recursos del Pod son la SUMA de los recursos de todos sus contenedores
#
# Recursos totales de este Pod:
# - Requests: cpu=500m, memory=256Mi
# - Limits:   cpu=1, memory=512Mi
# =============================================================================

apiVersion: v1
kind: Pod
metadata:
  name: multi-container-resources
  labels:
    app: demo
    example: multi-container
spec:
  containers:
  
  # Contenedor principal - aplicación web
  - name: web
    image: nginx:1.25-alpine
    resources:
      requests:
        cpu: "250m"
        memory: "128Mi"
      limits:
        cpu: "500m"
        memory: "256Mi"
    ports:
    - containerPort: 80
  
  # Contenedor sidecar - recolector de logs
  - name: log-collector
    image: busybox:1.36
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "Log collector starting..."
        while true; do
          echo "$(date): Collecting logs..."
          sleep 10
        done
    resources:
      requests:
        cpu: "250m"      # ← Se SUMA al request del contenedor web
        memory: "128Mi"
      limits:
        cpu: "500m"      # ← Se SUMA al limit del contenedor web
        memory: "256Mi"

---
# =============================================================================
# Ejemplo 03: Init Containers con Resources
# =============================================================================
#
# Los init containers NO se suman a los recursos del Pod.
# Se usa el MÁXIMO entre:
# - El máximo de los init containers
# - La suma de los containers normales
#
# En este ejemplo:
# - Init container: cpu=1, memory=512Mi
# - App container:  cpu=250m, memory=128Mi
# 
# Recursos efectivos del Pod:
# - Requests: cpu=1 (max), memory=512Mi (max)
# - Limits:   cpu=1, memory=512Mi
# =============================================================================

apiVersion: v1
kind: Pod
metadata:
  name: init-container-resources
  labels:
    app: demo
    example: init-containers
spec:
  
  # Init containers: Se ejecutan ANTES de los containers normales
  initContainers:
  - name: init-setup
    image: busybox:1.36
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "Initializing application..."
        echo "Downloading configuration..."
        sleep 5
        echo "Setup complete!"
    resources:
      requests:
        cpu: "1"         # ← Init container necesita 1 CPU
        memory: "512Mi"
      limits:
        cpu: "1"
        memory: "512Mi"
  
  # Containers normales
  containers:
  - name: app
    image: nginx:1.25-alpine
    resources:
      requests:
        cpu: "250m"      # ← Menor que el init container
        memory: "128Mi"
      limits:
        cpu: "500m"
        memory: "256Mi"
    ports:
    - containerPort: 80

---
# =============================================================================
# Ejemplo 04: Solo Requests (sin Limits)
# =============================================================================
#
# Si especificas requests pero NO limits:
# - El contenedor tiene recursos GARANTIZADOS (requests)
# - Puede usar TODOS los recursos disponibles del nodo (peligroso)
# - QoS Class: Burstable
#
# ⚠️ NO recomendado para producción
# =============================================================================

apiVersion: v1
kind: Pod
metadata:
  name: request-only
  labels:
    app: demo
    example: request-only
  annotations:
    warning: "Sin limits - puede consumir todos los recursos del nodo"
spec:
  containers:
  - name: nginx
    image: nginx:1.25-alpine
    resources:
      requests:
        cpu: "250m"
        memory: "128Mi"
      # ⚠️ Sin limits - puede usar toda la CPU/memoria disponible

---
# =============================================================================
# Ejemplo 05: Solo Limits (sin Requests)
# =============================================================================
#
# Si especificas limits pero NO requests:
# - Kubernetes COPIA automáticamente el limit al request
# - Equivale a: requests.cpu=500m, requests.memory=256Mi
# - QoS Class: Guaranteed (porque request == limit)
#
# ⚠️ Puede resultar en over-provisioning (reserva más de lo necesario)
# =============================================================================

apiVersion: v1
kind: Pod
metadata:
  name: limit-only
  labels:
    app: demo
    example: limit-only
  annotations:
    note: "Kubernetes copia limits a requests automáticamente"
spec:
  containers:
  - name: nginx
    image: nginx:1.25-alpine
    resources:
      # ❌ Sin requests definidos
      limits:
        cpu: "500m"
        memory: "256Mi"
    # Kubernetes internamente asigna:
    # requests.cpu = "500m"
    # requests.memory = "256Mi"

---
# =============================================================================
# Ejemplo 06: Ephemeral Storage
# =============================================================================
#
# Además de CPU y memoria, puedes limitar el almacenamiento efímero:
# - emptyDir volumes (excepto tmpfs)
# - Logs de contenedor
# - Writable container layers
#
# ⚠️ Si excede el límite → Pod eviction (no OOMKill)
# =============================================================================

apiVersion: v1
kind: Pod
metadata:
  name: ephemeral-storage-demo
  labels:
    app: demo
    example: ephemeral-storage
spec:
  containers:
  - name: app
    image: nginx:1.25-alpine
    resources:
      requests:
        cpu: "250m"
        memory: "128Mi"
        ephemeral-storage: "1Gi"   # Mínimo de storage efímero
      limits:
        cpu: "500m"
        memory: "256Mi"
        ephemeral-storage: "2Gi"   # Máximo de storage efímero
    
    volumeMounts:
    - name: cache
      mountPath: /cache
    - name: logs
      mountPath: /var/log/nginx
  
  volumes:
  - name: cache
    emptyDir:
      sizeLimit: "500Mi"  # ✅ Límite específico del volumen
  
  - name: logs
    emptyDir:
      sizeLimit: "500Mi"

---
# =============================================================================
# COMANDOS ÚTILES PARA TESTING
# =============================================================================

# 1. Crear los Pods
kubectl apply -f requests-limits-basic.yaml

# 2. Ver los Pods creados
kubectl get pods -l example

# 3. Ver recursos asignados
kubectl describe pod requests-limits-basic

# Buscar la sección:
# Containers:
#   nginx:
#     Limits:
#       cpu:     500m
#       memory:  256Mi
#     Requests:
#       cpu:        250m
#       memory:     128Mi

# 4. Ver QoS Class asignada
kubectl get pod requests-limits-basic -o jsonpath='{.status.qosClass}'
# Output: Burstable

kubectl get pod limit-only -o jsonpath='{.status.qosClass}'
# Output: Guaranteed (porque request == limit)

# 5. Monitorear uso de recursos (requiere metrics-server)
kubectl top pod requests-limits-basic

# Salida ejemplo:
# NAME                     CPU(cores)   MEMORY(bytes)
# requests-limits-basic    5m           10Mi

# 6. Ver recursos del nodo donde se programó
POD_NODE=$(kubectl get pod requests-limits-basic -o jsonpath='{.spec.nodeName}')
kubectl describe node $POD_NODE

# Buscar:
# Allocated resources:
#   (Total limits may be over 100%, i.e., overcommitted)
#   Resource           Requests      Limits
#   --------           --------      ------
#   cpu                1500m (37%)   3000m (75%)
#   memory             3Gi (40%)     6Gi (80%)

# 7. Ver eventos del Pod
kubectl get events --field-selector involvedObject.name=requests-limits-basic

# 8. Eliminar los Pods de prueba
kubectl delete -f requests-limits-basic.yaml

# =============================================================================
# NOTAS IMPORTANTES
# =============================================================================
#
# 1. Unidades de CPU:
#    - "1" = 1 CPU core completo
#    - "0.5" = 500m = medio CPU core
#    - "100m" = 0.1 CPU core
#    - Precisión mínima: 1m (0.001 CPU)
#
# 2. Unidades de Memory:
#    - Sufijos: E, P, T, G, M, k (decimal)
#    - Sufijos: Ei, Pi, Ti, Gi, Mi, Ki (binario - recomendado)
#    - "128Mi" = 128 Mebibytes = 134,217,728 bytes
#    - "128M" = 128 Megabytes = 128,000,000 bytes
#
# 3. QoS Classes (asignadas automáticamente):
#    - Guaranteed: Todos los contenedores tienen request == limit (CPU + Memory)
#    - Burstable: Al menos un contenedor tiene request o limit
#    - BestEffort: Ningún contenedor tiene requests ni limits
#
# 4. Enforcement:
#    - CPU: Throttling (restricción de tiempo, no termina el proceso)
#    - Memory: OOMKilled (termina con Exit Code 137)
#    - Ephemeral Storage: Eviction (no reinicia automáticamente)
#
# 5. Scheduler:
#    - Solo considera REQUESTS (no limits)
#    - Verifica: sum(pod.requests) <= node.allocatable
#    - No considera el uso real de recursos
#
# =============================================================================
